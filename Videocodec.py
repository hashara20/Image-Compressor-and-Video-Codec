# -*- coding: utf-8 -*-
"""miniproject_videocodec_other_frames virsion 6.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1mnK8T7jXGuesSd6I6jh7WuCPJAJChLC4
"""

import cv2
from collections import Counter
import heapq
import numpy as np
from google.colab.patches import cv2_imshow




# Path to the video file
video_path = "video1.mp4"  # Replace with your video file path

#output file
encode = 'huffman_encoded_values.txt'
motion = 'motion.txt'


file1=open(encode, 'wb')
file1=open(encode, 'r+b')

file2=open(motion,'w')
file2=open(motion, 'r+')


# Open the video file
cap = cv2.VideoCapture(video_path)

# Initialize frame counter and list for storing grayscale matrices
frame_counter = 0
grayscale_matrices = []
framesc=[]

# Read frames from the video and store them as grayscale matrices
while cap.isOpened():
    # Read the frame
    ret, frame = cap.read()

    # Break the loop if there are no more frames
    if not ret:
        break

    # Convert the frame to grayscale
    grayscale_frame = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)

    # Store the grayscale frame as a matrix
    grayscale_matrices.append(grayscale_frame)

    # Increment the frame counter
    frame_counter += 1

# Release the video capture and close any open windows
cap.release()
cv2.destroyAllWindows()

# Convert the list of grayscale matrices to a NumPy array
grayscale_matrices = np.array(grayscale_matrices)
height , width = grayscale_matrices[0].shape

#size of the image
vertical =height//8
horizontal=width//8

frames=[]

for x in range(len(grayscale_matrices)):

    macro_blocks = []

    for i in range(horizontal):
        for j in range(vertical):
            block = grayscale_matrices[x][j * 8:j * 8 + 8, i * 8:i * 8 + 8]
            macro_blocks.append(block)

    frames.append(macro_blocks)


def calculate_sad(block1, block2):
    # Calculate the Sum of Absolute Differences (SAD) between two macroblocks
    return np.sum(np.abs(block1 - block2))


def find_motion_vectors(ref_list, search_list):
    num_blocks = len(search_list)

    motion_vectors = []

    for i in range(num_blocks):
        search_block = search_list[i]

        min_sad = float('inf')
        best_match = None
        index=0

        # apply a search window
        for j in range(-4,5):
            for k in range(-6,7):
               if i+k+80*j<0:
                 ref_block = ref_list[0]
                 index=0
               elif i+k+80*j>=num_blocks:
                  ref_block = ref_list[num_blocks-1]
                  index=num_blocks-1
               else:
                  ref_block = ref_list[i+k+80*j]
                  index=i+k+80*j

               sad = calculate_sad(ref_block, search_block)

               if sad < min_sad:
                    min_sad = sad
                    best_match = index

        motion_vectors.append(best_match)

    return motion_vectors


for a in range(33):
    #reference frame

    # Aply Discrete cosine transform for each block
    dct_blocks = []

    for i in range(len(frames[0])):
        dct = cv2.dct(np.float32(frames[2*a][i]), cv2.DCT_INVERSE)
        dct_blocks.append((dct.round()).astype(int))



    #apply quantization for each block
    quantized_blocks = []
    quantization_level=10  #quantizaation level

    for i in range(len(frames[0])):
        quantized_blocks.append((np.round(dct_blocks[i] / quantization_level)).astype(int))

    #flatten the list
    flattened_list = []

    for i in range(len(frames[0])):
        for j in range(8):
            for k in range(8):
                flattened_list.append(quantized_blocks[i][j][k])



    # Huffman Encoding
    class Node:
        def __init__(self, value, freq):
            self.value = value
            self.freq = freq
            self.left = None
            self.right = None

        def __lt__(self, other):
            return self.freq < other.freq

    # Calculate frequency of each value
    def calculate_frequency(values):
        frequency = Counter(values)
        return frequency

    # Generate Huffman tree
    def construct_huffman_tree(frequency):
        heap = []
        for value, freq in frequency.items():
            heapq.heappush(heap, Node(value, freq))

        while len(heap) > 1:
            node1 = heapq.heappop(heap)
            node2 = heapq.heappop(heap)
            merged = Node(None, node1.freq + node2.freq)
            merged.left = node1
            merged.right = node2
            heapq.heappush(heap, merged)

        return heap[0]

    # Generate Huffman codebook
    def generate_huffman_codes(root):
        codebook = {}

        def traverse(node, code):
            if node.value is not None:
                codebook[node.value] = code
            else:
                traverse(node.left, code + '0')
                traverse(node.right, code + '1')

        traverse(root, '')
        return codebook

    # Encode values using Huffman codes
    def encode_values(values, codebook):
        encoded_values = ''
        for value in values:
            encoded_values += codebook[value]
        return encoded_values



    # Calculate frequency and construct Huffman tree
    frequency = calculate_frequency(flattened_list)
    huffman_tree = construct_huffman_tree(frequency)

    # Generate Huffman codebook
    codebook = generate_huffman_codes(huffman_tree)
    framesc.append(codebook)

    # Encode values
    encoded_values = encode_values(flattened_list, codebook)

    # Pad the encoded data
    padding_length = 8 - len(encoded_values) % 8
    encoded_values += "0" * padding_length
    padding_info = format(padding_length, '08b')
    encoded_values = padding_info + encoded_values

    # Convert encoded data to bytes
    byte_array = bytearray()
    for i in range(0, len(encoded_values), 8):
        byte = encoded_values[i:i + 8]
        byte_array.append(int(byte, 2))

    # Save encoded data as a binary file
    file1.write(b"\n"+"specialf".encode('utf-8')+str(2*a).encode('utf-8')+b"\n")
    file1.write(byte_array)
    file1.write(b"\n"+"specials".encode('utf-8')+str(2*a).encode('utf-8')+b"\n")
    #wrote the encode of reference




    #encode for residuals..........................
    for b in range(2*a+1,2*a+2):

        motionvec=[]
        motionvec=find_motion_vectors(frames[2*a],frames[b])

        #save motion vectors

        file2.write("\n"+"specialmotionf"+str(b)+"\n")
        for item in motionvec:
           file2.write(str(item)+ ' ')
        file2.write("\n"+"specialmotions"+str(b)+"\n")


        predicted=[]  # to store predicted image using reference

        for i in range(len(frames[0])):
            predicted.append(np.float32(frames[2*a][motionvec[i]]))

        residual=[] # current_frame - predicted current frame

        for i in range(len(frames[0])):
            residual.append(frames[b][i]-predicted[i])

        dct_blocks = []
        for i in range(len(frames[0])):
            dct = cv2.dct(np.float32(residual[i]), cv2.DCT_INVERSE)
            dct_blocks.append((dct.round()).astype(int))



        #apply quantization for each block
        quantized_blocks = []
        quantization_level=10  #quantizaation level

        for i in range(len(residual)):
            quantized_blocks.append((np.round(dct_blocks[i] / quantization_level)).astype(int))

        #flatten the list
        flattened_list = []

        for i in range(len(residual)):
            for j in range(8):
                for k in range(8):
                    flattened_list.append(quantized_blocks[i][j][k])

        # Huffman Encoding
        class Node:
            def __init__(self, value, freq):
                self.value = value
                self.freq = freq
                self.left = None
                self.right = None

            def __lt__(self, other):
                return self.freq < other.freq

        # Calculate frequency of each value
        def calculate_frequency(values):
            frequency = Counter(values)
            return frequency

        # Generate Huffman tree
        def construct_huffman_tree(frequency):
            heap = []
            for value, freq in frequency.items():
                heapq.heappush(heap, Node(value, freq))

            while len(heap) > 1:
                node1 = heapq.heappop(heap)
                node2 = heapq.heappop(heap)
                merged = Node(None, node1.freq + node2.freq)
                merged.left = node1
                merged.right = node2
                heapq.heappush(heap, merged)

            return heap[0]

        # Generate Huffman codebook
        def generate_huffman_codes(root):
            codebook = {}

            def traverse(node, code):
                if node.value is not None:
                    codebook[node.value] = code
                else:
                    traverse(node.left, code + '0')
                    traverse(node.right, code + '1')

            traverse(root, '')
            return codebook

        # Encode values using Huffman codes
        def encode_values(values, codebook):
            encoded_values = ''
            for value in values:
                encoded_values += codebook[value]
            return encoded_values


        # Calculate frequency and construct Huffman tree
        frequency = calculate_frequency(flattened_list)
        huffman_tree = construct_huffman_tree(frequency)

        # Generate Huffman codebook
        codebook = generate_huffman_codes(huffman_tree)
        framesc.append(codebook)

        # Encode values
        encoded_values = encode_values(flattened_list, codebook)

        # Pad the encoded data
        padding_length = 8 - len(encoded_values) % 8
        encoded_values += "0" * padding_length
        padding_info = format(padding_length, '08b')
        encoded_values = padding_info + encoded_values

        # Convert encoded data to bytes
        byte_array = bytearray()
        for i in range(0, len(encoded_values), 8):
            byte = encoded_values[i:i + 8]
            byte_array.append(int(byte, 2))

        # Save encoded data as a binary file
        file1.write(b"\n"+"specialf".encode('utf-8')+str(b).encode('utf-8')+b"\n")
        file1.write(byte_array)
        file1.write(b"\n"+"specials".encode('utf-8')+str(b).encode('utf-8')+b"\n")



#close files
file1.close
file2.close

#........................

#function to read in between two words

def read_text_between_special_words(filename, start_word, end_word):
    start_word=start_word.encode('utf-8')
    end_word=end_word.encode('utf-8')


    with open(filename, 'rb') as file:
        content = file.read()

    # Find the start and end positions of the special words
    start_pos = content.find(start_word)
    end_pos = content.find(end_word, start_pos + len(start_word))

    # Extract the text between the special words
    if start_pos != -1 and end_pos != -1:
        extracted_text = content[start_pos + len(start_word): end_pos].strip()
        return extracted_text
    else:
        return None

#function to read in between two words

def read_text_between_special_words_fortext(filename, start_word, end_word):


    with open(filename, 'r') as file:
        content = file.read()

    # Find the start and end positions of the special words
    start_pos = content.find(start_word)
    end_pos = content.find(end_word, start_pos + len(start_word))

    # Extract the text between the special words
    if start_pos != -1 and end_pos != -1:
        extracted_text = content[start_pos + len(start_word): end_pos].strip()
        return extracted_text
    else:
        return None



#Huffman decode.......................

matrix_final = np.empty(30, dtype=object)

for a in range(30):
    def decode_values(encoded_values, codebook):
        decoded_values = []
        current_code = ""
        for bit in encoded_values:
            current_code += bit
            for value, code in codebook.items():
                if current_code == code:
                    decoded_values.append(value)
                    current_code = ""
                    break
        return decoded_values

    # Read encoded values from the binary file
    start="specialf"+str(2*a)
    stop="specials"+str(2*a)



    byte_array = read_text_between_special_words(encode,start,stop)

    binary_data = ""
    for byte in byte_array:
        binary_data += format(byte, '08b')

    padding_length = int(binary_data[:8], 2)
    binary_data = binary_data[8:-padding_length]

    codebook=framesc[2*a]
    decoded_values = decode_values(binary_data, codebook)



    #re generate the list
    regenerated_quantized = np.empty((vertical, horizontal), dtype=object)

    # re form the 2D array as 8*8 blocks of elements
    x=0
    while(x<len(decoded_values)):
        for i in range(horizontal):
            for j in range(vertical):
                reqaunt = np.zeros((8, 8)).astype(int)
                for k in range(8):
                    for l in range(8):
                        reqaunt[k, l] = decoded_values[x]
                        x+=1
                        regenerated_quantized[j,i]=reqaunt

    # decontization
    dequantized_blocks= np.empty((vertical, horizontal), dtype=object)

    for i in range(horizontal):
        for j in range(vertical):
            dequantized_blocks[j,i]=(regenerated_quantized[j,i]*quantization_level).astype(float)


    # apply inverse discrete cosine transform
    inv_dct_blocks= np.empty((vertical, horizontal), dtype=object)

    for i in range(horizontal):
        for j in range(vertical):
            inv_dct_blocks[j,i]= cv2.idct(dequantized_blocks[j,i])

    #store
    regenerated_frames.append(inv_dct_blocks)

    matrix_storage = np.empty(30, dtype=object)
    matrix_storage[a]=inv_dct_blocks

    # for residuals.....................................................................
    for b in range(2*a+1,2*a+2):
      # read motion vectors
      start="specialmotionf"+str(b)
      stop="specialmotions"+str(b)

      motionvect=[]
      motionvect=read_text_between_special_words_fortext(motion,start,stop)

      elements_list = motionvect.split()

      rows = vertical
      cols = horizontal

      remotion = [[int(elements_list[i * cols + j]) for j in range(cols)] for i in range(rows)]


      #re form the residuals...........
      def decode_values(encoded_values, codebook):
        decoded_values = []
        current_code = ""
        for bit in encoded_values:
            current_code += bit
            for value, code in codebook.items():
                if current_code == code:
                    decoded_values.append(value)
                    current_code = ""
                    break
        return decoded_values

      # Read encoded values from the binary file
      start="specialf"+str(b)
      stop="specials"+str(b)



      byte_array = read_text_between_special_words(encode,start,stop)

      binary_data = ""
      for byte in byte_array:
          binary_data += format(byte, '08b')

      padding_length = int(binary_data[:8], 2)
      binary_data = binary_data[8:-padding_length]

      codebook=framesc[b]
      decoded_values = decode_values(binary_data, codebook)



      #re generate the list
      residual_quantized = np.empty((vertical, horizontal), dtype=object)

      # re form the 2D array as 8*8 blocks of elements
      x=0
      while(x<len(decoded_values)):
          for i in range(horizontal):
              for j in range(vertical):
                  reqaunt = np.zeros((8, 8)).astype(int)
                  for k in range(8):
                      for l in range(8):
                          reqaunt[k, l] = decoded_values[x]
                          x+=1
                          residual_quantized[j,i]=reqaunt



      current_regen=np.empty((vertical, horizontal), dtype=object)

      for i in range(horizontal):
        for j in range(vertical):
          u=remotion[j][i]

          current_regen[j,i]=inv_dct_blocks[u//horizontal,u%horizontal]

      current=np.empty((vertical, horizontal), dtype=object)

      for i in range(horizontal):
        for j in range(vertical):
          current[j,i]=current_regen[j,i]+residual_quantized[j,i]





      # decontization
      dequantized_blocks= np.empty((vertical, horizontal), dtype=object)

      for i in range(horizontal):
          for j in range(vertical):
              dequantized_blocks[j,i]=(current[j,i]*quantization_level).astype(float)


      # apply inverse discrete cosine transform
      inv_dct_blocks_current= np.empty((vertical, horizontal), dtype=object)

      for i in range(horizontal):
          for j in range(vertical):
              inv_dct_blocks_current[j,i]= cv2.idct(dequantized_blocks[j,i])

        # convert re generated 2D array into the image_matrix

    def recontruct_img_matrix(idctblocks):

        imgmatrix = np.zeros((horizontal * 8, vertical * 8))
        for i in range(horizontal):
            for j in range(vertical):
                imgmatrix[i*8:i*8+8,j*8:j*8+8]=idctblocks[j,i].T

        return imgmatrix.T

    matrix_final[a]=recontruct_img_matrix(matrix_storage[a])
    # display the images
    cv2_imshow(matrix_final[a])  # transmit image
    cv2.waitKey(0)
    cv2.destroyAllWindows()
    if(a==28):
      break